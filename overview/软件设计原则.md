# 软件设计原则
   - 原则：
        - 开闭原则
        - 里式代换原则
        - 依赖倒转原则
        - 接口隔离原则
        - 迪米特法则
        - 合成复用原则
        
   - 目的：可维护性、可复用性、可扩展性、灵活性

## 开闭原则
  - 对扩展开放，对修改关闭
  - 接口和抽象类
    - 相同点
        - 接口和抽象类均不能被实例化，均位于继承树的顶端，只能被其他类实现和继承
        - 接口和抽象都可以包含抽象方法
        
    - 不同点（新版JDK有新的特性）
        - 接口中只能包含抽象方法，抽象类可以包含普通方法
        - 接口不能定义静态方法，抽象类可以定义静态方法
        - 接口只能定义静态变量，抽象类可以定义静态变量，也可以定义成员变量
        - 接口不包含构造器，抽象类可以包含构造器（抽象类的构造器不用于创建对象，而是让子类调用抽象类的构造器来完成抽象类的初始化操作）
        - 一个类最多只有一个直接父类（包括抽象类），一个类可以实现多个接口，用于弥补Java单继承的不足
    
    - 使用抽象类的场景
        - 在几个关联紧密（有相同属性）的类之间共享代码
     
    - 使用接口的场景、
        - 利用多继承优势
        - 指定特定的数据类型行为，不关心由谁来实现这一行为
        - 接口可以看成是一个类和外部环境之间的联系

## 里式代换原则
  - 继承必须确保基类所拥有的性质在子类中仍然成立
  - 人能听懂的说法：子类可以扩展父类的功能，但不能改变父类的功能
  - 在子类添加新方法，不要重写父类的方法
  
## 依赖倒转原则
   - 面向接口编程，不要面向实现编程
   - 高层模块不应该依赖于低层模块，两者都应该依赖于其抽象
   - 抽象不应该依赖于细节，细节应该依赖抽象
   
   - 高层模块和低层模块
     - 被依赖的是低层模块（例如：adapter中连接外部环境的接口）
     - 调用低层模块的是高层模块（domain中的逻辑）
   
   
## 接口隔离原则
   - 客户端不应该被迫依赖于它不适用的方法
   - 一个类对另一个类的依赖应该建立在最小的**接口**上 

## 迪米特法则
   - 最少知识原则
   - 只和直接朋友交谈，不跟“陌生人说话”
   - 如果两个软件实体无需直接通信，则不应该发生直接的相互调用，可以通过第三方转发该调用
   - 例如：客户需要一个软件，但客户不会与软件工程师点对点沟通，而是将需求提给软件公司，软件公司再将需求传递给软件开发工程师
   - 降低类之间的耦合度，提高模块之间的相对独立性
   - 朋友的定义：
        - 当前对象本身
        - 当前对象的成员变量
        - 当前对象所创建的对象
        - 当前对象的方法参数
   - 将不同的类通过聚合关系放在同一个三方类/代理类中，作为三方类/代理类的成员属性
   
## 合成复用原则
   - 尽量先使用组合或聚合等关联关系来实现，其次才考虑使用继承关系来实现
   - 类的复用：
    - 继承复用
        - 又称“白箱复用”
        - 缺点：
            - 破坏封装性：继承会将父类的实现细节暴露给子类，父类对子类透明，子类可以进行覆盖
            - 耦合度高：父类中的实现发生的任何改变都会导致子类的实现发生变化，不利于类的扩展与维护
            - 限制复用的灵活性：从父类继承而来的实现是静态的，子类与父类的关系在编译时已经定义，在运行时不可能发生改变
    - 合成复用
        - 又称“黑箱复用”
        - 将已有对象纳入到新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能
        - 优点：
            - 维持类的封装性：成员对象的内部细节不对新对象透明
            - 对象间的耦合度低：可以在新对象的成员位置声明抽象
            - 复用的灵活性高：复用可以在运行时动态进行，新对象可以动态的引用与成员对象类型匹配的对象